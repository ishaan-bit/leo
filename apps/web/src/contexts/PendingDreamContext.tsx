'use client';

/**
 * Pending Dream Letter Context
 * Global state for epistolary dream letters generated by nightly_dream_generator
 * 
 * Flow:
 * 1. On login, check GET /api/dreams/pending once
 * 2. Store result in context (pendingDream state)
 * 3. Scene_Reflect shows popup if pendingDream exists
 * 4. MomentsLibrary auto-opens the reflection and scrolls to letter
 * 5. On "read" → DELETE /api/dreams/pending + clear context
 */

import React, { createContext, useContext, useState, useEffect } from 'react';
import { useSession } from 'next-auth/react';

/**
 * Dream letter structure from nightly_dream_generator
 */
interface PendingDreamLetter {
  letter_text: string;
  created_at: string; // ISO timestamp
  expiresAt: string; // ISO timestamp
}

/**
 * Context state shape
 */
interface PendingDreamContextValue {
  pendingDream: PendingDreamLetter | null;
  hasChecked: boolean; // Prevent duplicate API calls
  isChecking: boolean; // Loading state
  checkPendingDream: () => Promise<void>; // Manual trigger
  clearPendingDream: () => Promise<void>; // Mark as read
}

const PendingDreamContext = createContext<PendingDreamContextValue | null>(null);

/**
 * Provider component - wraps app to provide pending dream state
 */
export function PendingDreamProvider({ children }: { children: React.ReactNode }) {
  const { data: session, status } = useSession();
  const [pendingDream, setPendingDream] = useState<PendingDreamLetter | null>(null);
  const [hasChecked, setHasChecked] = useState(false);
  const [isChecking, setIsChecking] = useState(false);

  /**
   * Check for pending dream letter from API
   */
  const checkPendingDream = async () => {
    if (hasChecked || isChecking) {
      console.log('[PendingDream] Skipping check - already checked or checking');
      return;
    }

    try {
      setIsChecking(true);
      console.log('[PendingDream] Checking for pending dream letter...');

      const response = await fetch('/api/dreams/pending', {
        method: 'GET',
        headers: { 'Content-Type': 'application/json' },
      });

      if (response.status === 404) {
        // No pending dream
        console.log('[PendingDream] No pending dream found');
        setPendingDream(null);
        setHasChecked(true);
        return;
      }

      if (!response.ok) {
        throw new Error(`Failed to check pending dream: ${response.statusText}`);
      }

      const data = await response.json();
      
      if (data.exists && data.dream) {
        console.log('[PendingDream] ✨ Found pending dream letter!', {
          created_at: data.dream.created_at,
          letter_preview: data.dream.letter_text.substring(0, 100) + '...',
        });
        setPendingDream(data.dream);
      } else {
        console.log('[PendingDream] No pending dream');
        setPendingDream(null);
      }

      setHasChecked(true);
    } catch (error) {
      console.error('[PendingDream] Error checking pending dream:', error);
      setHasChecked(true); // Mark as checked to prevent retry loops
    } finally {
      setIsChecking(false);
    }
  };

  /**
   * Clear pending dream (mark as read)
   */
  const clearPendingDream = async () => {
    try {
      console.log('[PendingDream] Marking dream as read...');

      const response = await fetch('/api/dreams/pending', {
        method: 'DELETE',
      });

      if (response.ok || response.status === 204) {
        console.log('[PendingDream] ✅ Dream marked as read');
        setPendingDream(null);
      } else {
        throw new Error(`Failed to delete pending dream: ${response.statusText}`);
      }
    } catch (error) {
      console.error('[PendingDream] Error deleting pending dream:', error);
      // Still clear from UI even if API fails (user experience)
      setPendingDream(null);
    }
  };

  /**
   * Auto-check on authentication
   * Triggers when user logs in (status changes from 'loading' to 'authenticated')
   * CRITICAL: Only runs for signed-in users - never for guests (status === 'unauthenticated')
   */
  useEffect(() => {
    // Guard: Only check for authenticated users, never for guests
    if (status === 'unauthenticated') {
      console.log('[PendingDream] Guest mode - skipping dream check (dream letters are signed-in only)');
      setHasChecked(true); // Mark as checked to prevent future attempts
      setPendingDream(null); // Ensure no stale dream data
      return;
    }
    
    if (status === 'authenticated' && session?.user && !hasChecked && !isChecking) {
      console.log('[PendingDream] User authenticated, checking for pending dream...');
      checkPendingDream();
    }
  }, [status, session, hasChecked, isChecking]);

  const contextValue: PendingDreamContextValue = {
    pendingDream,
    hasChecked,
    isChecking,
    checkPendingDream,
    clearPendingDream,
  };

  return (
    <PendingDreamContext.Provider value={contextValue}>
      {children}
    </PendingDreamContext.Provider>
  );
}

/**
 * Hook to access pending dream context
 * Must be used within PendingDreamProvider
 */
export function usePendingDream(): PendingDreamContextValue {
  const context = useContext(PendingDreamContext);
  
  if (!context) {
    throw new Error('usePendingDream must be used within PendingDreamProvider');
  }
  
  return context;
}
